package http

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"text/template"
)

// 生成导入代码的模板
const routeImportTpl = `// Code generated by go-common auto-gen; DO NOT EDIT.
package {{.PackageName}}

import (
{{range .Routes}}
	_ "{{.ModuleName}}/{{.Path}}"
{{end}}
)

// Init 空函数，防止编译器优化掉导入
func Init() {}
`

// RouteGenInfo 路由包信息
type RouteGenInfo struct {
	ModuleName string // 业务项目的go module名（如pano-material）
	Path       string // 路由包相对路径（如test、lecture）
}

// RouteGenConfig 生成配置
type RouteGenConfig struct {
	PackageName string         // 生成文件的包名（默认routes）
	Routes      []RouteGenInfo // 扫描到的路由包
}

// AutoGenRouteImport 自动生成路由导入代码（支持通配符匹配）
// 参数说明：
// - moduleName: 业务项目的go module名（必填，如pano-material）
// - scanRoot: 扫描的根目录（默认当前目录，传""则用当前工作目录）
// - outputDir: 生成文件的目录（默认routes）
// - matchPatterns: 通配符匹配规则（逗号分隔，默认test,lecture,handler,*Route,*router）
// - ignoreDirs: 忽略的目录关键词（逗号分隔，默认vendor,testdata,docs）
func AutoGenRouteImport(moduleName, scanRoot, outputDir, matchPatterns, ignoreDirs string) error {
	// 1. 参数默认值处理
	if scanRoot == "" {
		var err error
		scanRoot, err = os.Getwd() // 获取当前工作目录
		if err != nil {
			return fmt.Errorf("获取当前目录失败：%v", err)
		}
	}
	if outputDir == "" {
		outputDir = "routes" // 默认生成到routes目录
	}
	// 默认支持的通配符规则：精确匹配+模糊匹配
	if matchPatterns == "" {
		matchPatterns = "test,lecture,handler,*Route,*router,handler/*"
	}
	if ignoreDirs == "" {
		ignoreDirs = "vendor,testdata,docs,node_modules,.git,.idea"
	}
	if moduleName == "" {
		return fmt.Errorf("moduleName不能为空（请传入业务项目的go module名，如pano-material）")
	}

	// 2. 创建routes目录（不存在则创建）
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		return fmt.Errorf("创建routes目录失败：%v", err)
	}

	// 3. 解析匹配规则（拆分为通配符列表）
	matchList := strings.Split(matchPatterns, ",")
	// 清理空规则
	for i := len(matchList) - 1; i >= 0; i-- {
		matchList[i] = strings.TrimSpace(matchList[i])
		if matchList[i] == "" {
			matchList = append(matchList[:i], matchList[i+1:]...)
		}
	}

	// 4. 解析忽略目录规则
	ignoreList := make(map[string]bool)
	for _, dir := range strings.Split(ignoreDirs, ",") {
		dir = strings.TrimSpace(dir)
		if dir != "" {
			ignoreList[dir] = true
		}
	}

	// 5. 扫描目录，收集路由包（核心：通配符匹配）
	var routes []RouteGenInfo
	err := filepath.Walk(scanRoot, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		// 跳过非目录、根目录、忽略目录
		if !info.IsDir() || path == scanRoot || ignoreList[filepath.Base(path)] {
			return nil
		}

		// 获取当前目录的基础名（如handler/user → user；orderRoute → orderRoute）
		dirBase := filepath.Base(path)
		// 获取当前目录的完整相对路径（用于匹配handler/*这类路径规则）
		relPath, _ := filepath.Rel(scanRoot, path)
		// 统一转为斜杠（兼容Windows）
		relPath = filepath.ToSlash(relPath)

		// 遍历所有匹配规则，只要满足一个就视为匹配成功
		matchSuccess := false
		for _, pattern := range matchList {
			// 规则1：匹配目录基础名（如*Route、*router）
			if ok, _ := filepath.Match(pattern, dirBase); ok {
				matchSuccess = true
				break
			}
			// 规则2：匹配完整相对路径（如handler/*）
			if ok, _ := filepath.Match(pattern, relPath); ok {
				matchSuccess = true
				break
			}
		}

		// 匹配成功则加入路由列表
		if matchSuccess {
			routes = append(routes, RouteGenInfo{
				ModuleName: moduleName,
				Path:       relPath,
			})
			fmt.Printf("[go-common] 匹配到路由包：%s/%s\n", moduleName, relPath)
		}
		return nil
	})
	if err != nil {
		return fmt.Errorf("扫描路由目录失败：%v", err)
	}

	// 6. 生成导入代码
	config := RouteGenConfig{
		PackageName: filepath.Base(outputDir), // 包名默认是目录名（routes）
		Routes:      routes,
	}
	tpl, err := template.New("routeImport").Parse(routeImportTpl)
	if err != nil {
		return fmt.Errorf("解析模板失败：%v", err)
	}

	// 7. 写入auto_import.go文件
	outputFile := filepath.Join(outputDir, "auto_import.go")
	f, err := os.Create(outputFile)
	if err != nil {
		return fmt.Errorf("创建auto_import.go失败：%v", err)
	}
	defer f.Close()

	if err := tpl.Execute(f, config); err != nil {
		return fmt.Errorf("生成auto_import.go内容失败：%v", err)
	}

	fmt.Printf("[go-common] 成功生成路由导入文件：%s（共%d个路由包）\n", outputFile, len(routes))
	return nil
}

//package http
//
//import (
//	"fmt"
//	"os"
//	"path/filepath"
//	"text/template"
//)
//
//// 生成导入代码的模板
//const routeImportTpl = `// Code generated by go-common auto-gen; DO NOT EDIT.
//package {{.PackageName}}
//
//import (
//{{range .Routes}}
//	_ "{{.ModuleName}}/{{.Path}}"
//{{end}}
//)
//
//// Init 空函数，防止编译器优化掉导入
//func Init() {}
//`
//
//// RouteGenInfo 路由包信息
//type RouteGenInfo struct {
//	ModuleName string // 业务项目的go module名（如pano-material）
//	Path       string // 路由包相对路径（如test、lecture）
//}
//
//// RouteGenConfig 生成配置
//type RouteGenConfig struct {
//	PackageName string         // 生成文件的包名（默认routes）
//	Routes      []RouteGenInfo // 扫描到的路由包
//}
//
//// AutoGenRouteImport 自动生成路由导入代码（核心函数）
//// 参数说明：
//// - moduleName: 业务项目的go module名（必填，如pano-material）
//// - scanRoot: 扫描的根目录（默认当前目录，传""则用当前工作目录）
//// - outputDir: 生成文件的目录（默认routes）
//// - matchDirs: 需要扫描的目录关键词（逗号分隔，默认test,lecture,handler）
//// - ignoreDirs: 忽略的目录关键词（逗号分隔，默认vendor,testdata,docs）
//func AutoGenRouteImport(moduleName, scanRoot, outputDir, matchDirs, ignoreDirs string) error {
//	// 1. 参数默认值处理
//	if scanRoot == "" {
//		var err error
//		scanRoot, err = os.Getwd() // 获取当前工作目录
//		if err != nil {
//			return fmt.Errorf("获取当前目录失败：%v", err)
//		}
//	}
//	if outputDir == "" {
//		outputDir = "routes" // 默认生成到routes目录
//	}
//	if matchDirs == "" {
//		matchDirs = "test,lecture,handler,user"
//	}
//	if ignoreDirs == "" {
//		ignoreDirs = "vendor,testdata,docs,node_modules,.git,.idea"
//	}
//	if moduleName == "" {
//		return fmt.Errorf("moduleName不能为空（请传入业务项目的go module名，如pano-material）")
//	}
//
//	// 2. 创建routes目录（不存在则创建）
//	if err := os.MkdirAll(outputDir, 0755); err != nil {
//		return fmt.Errorf("创建routes目录失败：%v", err)
//	}
//
//	// 3. 解析匹配/忽略目录规则
//	matchList := make(map[string]bool)
//	for _, dir := range filepath.SplitList(matchDirs) {
//		if dir != "" {
//			matchList[dir] = true
//		}
//	}
//	ignoreList := make(map[string]bool)
//	for _, dir := range filepath.SplitList(ignoreDirs) {
//		if dir != "" {
//			ignoreList[dir] = true
//		}
//	}
//
//	// 4. 扫描目录，收集路由包
//	var routes []RouteGenInfo
//	err := filepath.Walk(scanRoot, func(path string, info os.FileInfo, err error) error {
//		if err != nil {
//			return err
//		}
//		// 跳过非目录、根目录、忽略目录
//		if !info.IsDir() || path == scanRoot || ignoreList[filepath.Base(path)] {
//			return nil
//		}
//		// 匹配指定的路由目录关键词
//		base := filepath.Base(path)
//		if matchList[base] {
//			// 转换为相对路径（避免绝对路径）
//			relPath, _ := filepath.Rel(scanRoot, path)
//			routes = append(routes, RouteGenInfo{
//				ModuleName: moduleName,
//				Path:       relPath,
//			})
//			fmt.Printf("[go-common] 发现路由包：%s/%s\n", moduleName, relPath)
//		}
//		return nil
//	})
//	if err != nil {
//		return fmt.Errorf("扫描路由目录失败：%v", err)
//	}
//
//	// 5. 生成导入代码
//	config := RouteGenConfig{
//		PackageName: filepath.Base(outputDir), // 包名默认是目录名（routes）
//		Routes:      routes,
//	}
//	tpl, err := template.New("routeImport").Parse(routeImportTpl)
//	if err != nil {
//		return fmt.Errorf("解析模板失败：%v", err)
//	}
//	// 6. 写入auto_import.go文件
//	outputFile := filepath.Join(outputDir, "auto_import.go")
//	f, err := os.Create(outputFile)
//	if err != nil {
//		return fmt.Errorf("创建auto_import.go失败：%v", err)
//	}
//	defer f.Close()
//
//	if err := tpl.Execute(f, config); err != nil {
//		return fmt.Errorf("生成auto_import.go内容失败：%v", err)
//	}
//
//	fmt.Printf("[go-common] 成功生成路由导入文件：%s（共%d个路由包）\n", outputFile, len(routes))
//	return nil
//}
