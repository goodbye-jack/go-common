// go-common/autoimport/autoimport.go
package autoimport

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"strings"
	"text/template"
)

// 编译期初始化函数（最终修复版）
func init() {
	// 1. 优先从环境变量获取业务项目根目录（兼容IDE/命令行）
	rootDir := os.Getenv("PWD")
	if rootDir == "" {
		var err error
		rootDir, err = os.Getwd()
		if err != nil {
			return
		}
	}

	// 2. 扫描根目录下的main.go（直接识别main包）
	mainGoPath, err := findMainGo(rootDir)
	if err != nil {
		return
	}

	// 3. 验证是否为main包（AST解析确认）
	if !isMainPackage(mainGoPath) {
		return
	}

	// 4. 解析module名（从go.mod读取）
	moduleName, err := getModuleName(rootDir)
	if err != nil {
		return
	}

	// 5. 生成auto_import.go（修复路径拼接+模板语法）
	outputDir := filepath.Join(rootDir, "routes")
	_ = os.MkdirAll(outputDir, 0755)
	generateAutoImportFile(outputDir, moduleName, rootDir)

	// 6. 编译期注入routes.Init()到main.go（修复重复写入）
	injectRoutesInitToMain(mainGoPath, moduleName, outputDir)
}

// findMainGo 递归查找根目录下的main.go（兼容子目录）
func findMainGo(rootDir string) (string, error) {
	var mainGoPath string
	err := filepath.Walk(rootDir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return nil
		}
		if !info.IsDir() && strings.EqualFold(filepath.Base(path), "main.go") {
			mainGoPath = path
			return filepath.SkipAll // 找到第一个main.go就终止
		}
		return nil
	})
	if err != nil {
		return "", err
	}
	if mainGoPath == "" {
		return "", os.ErrNotExist
	}
	return mainGoPath, nil
}

// isMainPackage 解析AST确认是否为main包
func isMainPackage(filePath string) bool {
	fset := token.NewFileSet()
	file, err := parser.ParseFile(fset, filePath, nil, parser.PackageClauseOnly)
	if err != nil {
		return false
	}
	return file.Name.Name == "main"
}

// getModuleName 解析go.mod获取module名
func getModuleName(rootDir string) (string, error) {
	modFile := filepath.Join(rootDir, "go.mod")
	content, err := os.ReadFile(modFile)
	if err != nil {
		return "", err
	}
	lines := strings.Split(string(content), "\n")
	for _, line := range lines {
		trimLine := strings.TrimSpace(line)
		if strings.HasPrefix(trimLine, "module ") {
			return strings.TrimPrefix(trimLine, "module "), nil
		}
	}
	return "", os.ErrNotExist
}

// generateAutoImportFile 修复：路径拼接+模板语法错误
func generateAutoImportFile(outputDir, moduleName, rootDir string) {
	// 扫描业务项目的路由包（修复：过滤非handler包+正确拼接路径）
	routes := scanRoutes(rootDir)
	if len(routes) == 0 {
		return
	}

	// 修复模板：解决len([]interface{}{{range .}}nil,{{end}})语法错误
	tplContent := `// Code generated by go-common DO NOT EDIT.
package routes

import (
	"fmt"
	{{range .}}_ "{{$.ModuleName}}/{{.}}"
	{{end}}
)

func Init() {
	fmt.Printf("[go-common] 加载%d个路由包\n", len([]interface{}{{range .}}nil,{{end}}))
}
`
	tpl := template.Must(template.New("autoimport").Parse(tplContent))

	autoImportPath := filepath.Join(outputDir, "auto_import.go")
	// 修复：先清空旧文件（避免残留错误内容）
	f, err := os.Create(autoImportPath)
	if err != nil {
		return
	}
	defer f.Close()

	// 修复：传递正确的模板参数
	_ = tpl.Execute(f, map[string]interface{}{
		"ModuleName": moduleName,
		"Routes":     routes,
	})
}

// scanRoutes 修复：正确扫描internal/handler下的子包，避免路径拼接错误
func scanRoutes(rootDir string) []string {
	var routes []string
	handlerDir := filepath.Join(rootDir, "internal/handler")
	// 先检查handler目录是否存在
	if _, err := os.Stat(handlerDir); os.IsNotExist(err) {
		return routes
	}

	_ = filepath.Walk(handlerDir, func(path string, info os.FileInfo, err error) error {
		if err != nil || !info.IsDir() {
			return nil
		}
		// 过滤隐藏目录/测试目录/根目录（handler本身）
		if strings.HasPrefix(info.Name(), ".") ||
			strings.HasSuffix(info.Name(), "_test") ||
			path == handlerDir {
			return nil
		}
		// 修复：正确转换为相对包路径（如internal/handler/test）
		relPath, err := filepath.Rel(rootDir, path)
		if err != nil {
			return nil
		}
		// 修复：替换系统分隔符为/（兼容Windows）
		relPath = filepath.ToSlash(relPath)
		routes = append(routes, relPath)
		return filepath.SkipDir // 只扫描一级子目录，避免递归
	})
	return routes
}

// injectRoutesInitToMain 修复：彻底解决重复注入问题
func injectRoutesInitToMain(mainGoPath, moduleName, outputDir string) {
	// 1. 解析main.go AST
	fset := token.NewFileSet()
	file, err := parser.ParseFile(fset, mainGoPath, nil, parser.ParseComments|parser.AllErrors)
	if err != nil {
		return
	}

	// 2. 检查是否已存在有效routes.Init()调用（过滤注释+重复）
	if hasValidRoutesInit(file, moduleName, outputDir) {
		return
	}

	// 3. 读取main.go内容（修复：先去重已有导入/调用）
	content, err := os.ReadFile(mainGoPath)
	if err != nil {
		return
	}
	lines := strings.Split(string(content), "\n")

	// 3.1 先去重重复的routes导入
	importPath := fmt.Sprintf("%s/routes", moduleName)
	lines = removeDuplicateRoutesImport(lines, importPath)

	// 3.2 先去重重复的routes.Init()调用
	lines = removeDuplicateRoutesInit(lines)

	// 4. 注入routes包导入（仅当无有效导入时）
	if !hasRoutesImport(lines, importPath) {
		lines = injectRoutesImport(lines, importPath)
	}

	// 5. 注入routes.Init()到main函数第一行（仅当无有效调用时）
	if !hasRoutesInitCall(lines) {
		lines = injectRoutesInitCall(lines)
	}

	// 6. 写回main.go
	_ = os.WriteFile(mainGoPath, []byte(strings.Join(lines, "\n")), 0644)
}

// hasValidRoutesInit 检查是否存在有效routes.Init()调用
func hasValidRoutesInit(file *ast.File, moduleName, outputDir string) bool {
	importPath := fmt.Sprintf("%s/routes", moduleName)
	// 检查导入
	hasImport := false
	for _, imp := range file.Imports {
		if strings.Trim(imp.Path.Value, `"`) == importPath && imp.Comment == nil {
			hasImport = true
			break
		}
	}
	if !hasImport {
		return false
	}
	// 检查调用
	hasCall := false
	ast.Inspect(file, func(n ast.Node) bool {
		funcDecl, ok := n.(*ast.FuncDecl)
		if ok && funcDecl.Name.Name == "main" {
			for _, stmt := range funcDecl.Body.List {
				exprStmt, ok := stmt.(*ast.ExprStmt)
				if !ok {
					continue
				}
				callExpr, ok := exprStmt.X.(*ast.CallExpr)
				if !ok {
					continue
				}
				selExpr, ok := callExpr.Fun.(*ast.SelectorExpr)
				if !ok {
					continue
				}
				ident, ok := selExpr.X.(*ast.Ident)
				if ok && ident.Name == "routes" && selExpr.Sel.Name == "Init" {
					hasCall = true
					return false
				}
			}
		}
		return true
	})
	return hasCall
}

// removeDuplicateRoutesImport 去重重复的routes导入
func removeDuplicateRoutesImport(lines []string, importPath string) []string {
	var newLines []string
	importLine := fmt.Sprintf("import \"%s\"", importPath)
	found := false
	for _, line := range lines {
		trimLine := strings.TrimSpace(line)
		// 跳过重复的导入行
		if trimLine == importLine && found {
			continue
		}
		if trimLine == importLine {
			found = true
		}
		newLines = append(newLines, line)
	}
	return newLines
}

// removeDuplicateRoutesInit 去重重复的routes.Init()调用
func removeDuplicateRoutesInit(lines []string) []string {
	var newLines []string
	initCall := "routes.Init()"
	inMainFunc := false
	found := false
	for _, line := range lines {
		trimLine := strings.TrimSpace(line)
		// 标记是否进入main函数
		if trimLine == "func main() {" {
			inMainFunc = true
		}
		if inMainFunc && trimLine == "}" {
			inMainFunc = false
		}
		// 跳过重复的Init()调用
		if inMainFunc && trimLine == initCall && found {
			continue
		}
		if inMainFunc && trimLine == initCall {
			found = true
		}
		newLines = append(newLines, line)
	}
	return newLines
}

// hasRoutesImport 检查是否已有routes导入
func hasRoutesImport(lines []string, importPath string) bool {
	importLine := fmt.Sprintf("import \"%s\"", importPath)
	for _, line := range lines {
		if strings.TrimSpace(line) == importLine {
			return true
		}
		// 检查import块内的导入
		if strings.Contains(strings.TrimSpace(line), fmt.Sprintf(`"%s"`, importPath)) {
			return true
		}
	}
	return false
}

// hasRoutesInitCall 检查是否已有routes.Init()调用
func hasRoutesInitCall(lines []string) bool {
	inMainFunc := false
	for _, line := range lines {
		trimLine := strings.TrimSpace(line)
		if trimLine == "func main() {" {
			inMainFunc = true
		}
		if inMainFunc && trimLine == "}" {
			inMainFunc = false
		}
		if inMainFunc && trimLine == "routes.Init()" {
			return true
		}
	}
	return false
}

// injectRoutesImport 注入routes包导入（无重复）
func injectRoutesImport(lines []string, importPath string) []string {
	packageLine := -1
	importEndLine := -1
	for i, line := range lines {
		trimLine := strings.TrimSpace(line)
		if trimLine == "package main" {
			packageLine = i
		}
		if trimLine == ")" && importEndLine == -1 && i > 0 && strings.HasPrefix(strings.TrimSpace(lines[i-1]), "import (") {
			importEndLine = i
		}
	}

	if importEndLine > 0 {
		// 有import块，插入到块内
		newLines := append(lines[:importEndLine], fmt.Sprintf("\t\"%s\"", importPath))
		newLines = append(newLines, lines[importEndLine:]...)
		return newLines
	} else if packageLine >= 0 {
		// 无import块，插入到package main后
		newLines := append(lines[:packageLine+1], fmt.Sprintf("import \"%s\"", importPath))
		newLines = append(newLines, lines[packageLine+1:]...)
		return newLines
	}
	return lines
}

// injectRoutesInitCall 注入routes.Init()到main函数（无重复）
func injectRoutesInitCall(lines []string) []string {
	mainLine := -1
	for i, line := range lines {
		if strings.TrimSpace(line) == "func main() {" {
			mainLine = i
			break
		}
	}
	if mainLine == -1 {
		return lines
	}

	// 匹配缩进
	indent := strings.Repeat("\t", strings.Count(lines[mainLine], "\t"))
	// 修复：缩进后添加换行，保证格式美观
	newLines := append(lines[:mainLine+1], fmt.Sprintf("%s%s", indent, "routes.Init()"))
	newLines = append(newLines, lines[mainLine+1:]...)
	return newLines
}

//// go-common/autoimport/autoimport.go
//package autoimport
//
//import (
//	"fmt"
//	"go/ast"
//	"go/build"
//	"go/parser"
//	"go/token"
//	"os"
//	"path/filepath"
//	"strings"
//	"text/template"
//)
//
//// 编译期初始化函数（Go编译时优先执行，早于main包编译）
//func init() {
//	// 1. 获取当前编译的主包路径（业务项目main包）
//	pkg, err := build.Default.ImportDir(".", build.FindOnly)
//	if err != nil {
//		return // 非主包/无源码，直接退出
//	}
//
//	// 2. 过滤非main包（仅处理业务项目的main包编译）
//	if pkg.Name != "main" {
//		return
//	}
//
//	// 3. 查找main.go文件
//	mainGoPath := ""
//	for _, file := range pkg.GoFiles {
//		if strings.EqualFold(file, "main.go") {
//			mainGoPath = filepath.Join(pkg.Dir, file)
//			break
//		}
//	}
//	if mainGoPath == "" {
//		return
//	}
//
//	// 4. 解析业务项目module名（从go.mod读取）
//	moduleName, err := getModuleName(pkg.Dir)
//	if err != nil {
//		return
//	}
//
//	// 5. 生成auto_import.go（编译期生成）
//	outputDir := filepath.Join(pkg.Dir, "routes")
//	_ = os.MkdirAll(outputDir, 0755)
//	generateAutoImportFile(outputDir, moduleName, pkg.Dir)
//
//	// 6. 编译期注入routes.Init()到main.go（核心：零延迟）
//	injectRoutesInitToMain(mainGoPath, moduleName, outputDir)
//}
//
//// getModuleName 解析go.mod获取module名
//func getModuleName(rootDir string) (string, error) {
//	modFile := filepath.Join(rootDir, "go.mod")
//	content, err := os.ReadFile(modFile)
//	if err != nil {
//		return "", err
//	}
//	lines := strings.Split(string(content), "\n")
//	for _, line := range lines {
//		trimLine := strings.TrimSpace(line)
//		if strings.HasPrefix(trimLine, "module ") {
//			return strings.TrimPrefix(trimLine, "module "), nil
//		}
//	}
//	return "", os.ErrNotExist
//}
//
//// generateAutoImportFile 编译期生成auto_import.go
//func generateAutoImportFile(outputDir, moduleName, rootDir string) {
//	// 扫描业务项目的路由包（如internal/handler下的所有包）
//	routes := scanRoutes(rootDir)
//	if len(routes) == 0 {
//		return
//	}
//
//	// 渲染模板生成auto_import.go
//	tpl := template.Must(template.New("autoimport").Parse(`// Code generated by go-common DO NOT EDIT.
//package routes
//
//import (
//	"fmt"
//	{{range .}}_ "{{$.ModuleName}}/{{.}}"
//	{{end}}
//)
//
//func Init() {
//	fmt.Printf("[go-common] 加载%d个路由包\n", len([]interface{}{{range .}}nil,{{end}}))
//}
//`))
//
//	autoImportPath := filepath.Join(outputDir, "auto_import.go")
//	f, _ := os.Create(autoImportPath)
//	defer f.Close()
//	_ = tpl.Execute(f, map[string]interface{}{
//		"ModuleName": moduleName,
//		"Routes":     routes,
//	})
//}
//
//// scanRoutes 扫描业务项目的路由处理器包
//func scanRoutes(rootDir string) []string {
//	var routes []string
//	_ = filepath.Walk(filepath.Join(rootDir, "internal/handler"), func(path string, info os.FileInfo, err error) error {
//		if err != nil || !info.IsDir() {
//			return nil
//		}
//		// 过滤隐藏目录/测试目录
//		if strings.HasPrefix(info.Name(), ".") || strings.HasSuffix(info.Name(), "_test") {
//			return filepath.SkipDir
//		}
//		// 转换为包路径（如internal/handler/test）
//		relPath, _ := filepath.Rel(rootDir, path)
//		routes = append(routes, relPath)
//		return nil
//	})
//	return routes
//}
//
//// injectRoutesInitToMain 编译期注入routes.Init()到main.go
//func injectRoutesInitToMain(mainGoPath, moduleName, outputDir string) {
//	// 1. 解析main.go AST（编译期解析）
//	fset := token.NewFileSet()
//	file, err := parser.ParseFile(fset, mainGoPath, nil, parser.ParseComments|parser.AllErrors)
//	if err != nil {
//		return
//	}
//
//	// 2. 检查是否已存在有效routes.Init()调用（过滤注释）
//	if hasValidRoutesInit(file, moduleName, outputDir) {
//		return
//	}
//
//	// 3. 读取main.go内容
//	content, err := os.ReadFile(mainGoPath)
//	if err != nil {
//		return
//	}
//	lines := strings.Split(string(content), "\n")
//
//	// 4. 注入routes包导入
//	importPath := fmt.Sprintf("%s/routes", moduleName)
//	lines = injectRoutesImport(lines, importPath)
//
//	// 5. 注入routes.Init()到main函数第一行
//	lines = injectRoutesInitCall(lines)
//
//	// 6. 写回main.go（编译期写入，本次go build即可生效）
//	_ = os.WriteFile(mainGoPath, []byte(strings.Join(lines, "\n")), 0644)
//}
//
//// hasValidRoutesInit 检查是否存在有效routes.Init()调用
//func hasValidRoutesInit(file *ast.File, moduleName, outputDir string) bool {
//	// 检查导入
//	hasImport := false
//	importPath := fmt.Sprintf("%s/routes", moduleName)
//	for _, imp := range file.Imports {
//		if strings.Trim(imp.Path.Value, `"`) == importPath && imp.Comment == nil {
//			hasImport = true
//			break
//		}
//	}
//	if !hasImport {
//		return false
//	}
//
//	// 检查Init()调用
//	hasCall := false
//	ast.Inspect(file, func(n ast.Node) bool {
//		funcDecl, ok := n.(*ast.FuncDecl)
//		if ok && funcDecl.Name.Name == "main" {
//			for _, stmt := range funcDecl.Body.List {
//				exprStmt, ok := stmt.(*ast.ExprStmt)
//				if !ok {
//					continue
//				}
//				callExpr, ok := exprStmt.X.(*ast.CallExpr)
//				if !ok {
//					continue
//				}
//				selExpr, ok := callExpr.Fun.(*ast.SelectorExpr)
//				if !ok {
//					continue
//				}
//				ident, ok := selExpr.X.(*ast.Ident)
//				if ok && ident.Name == "routes" && selExpr.Sel.Name == "Init" {
//					hasCall = true
//					return false
//				}
//			}
//		}
//		return true
//	})
//	return hasCall
//}
//
//// injectRoutesImport 注入routes包导入
//func injectRoutesImport(lines []string, importPath string) []string {
//	// 查找import块/包声明位置
//	packageLine := -1
//	importEndLine := -1
//	for i, line := range lines {
//		trimLine := strings.TrimSpace(line)
//		if trimLine == "package main" {
//			packageLine = i
//		}
//		if trimLine == ")" && importEndLine == -1 && i > 0 && strings.HasPrefix(strings.TrimSpace(lines[i-1]), "import (") {
//			importEndLine = i
//		}
//	}
//
//	// 注入导入
//	if importEndLine > 0 {
//		// 有import块，插入到块内
//		newLines := append(lines[:importEndLine], fmt.Sprintf("\t\"%s\"", importPath))
//		newLines = append(newLines, lines[importEndLine:]...)
//		return newLines
//	} else if packageLine >= 0 {
//		// 无import块，插入到package main后
//		newLines := append(lines[:packageLine+1], fmt.Sprintf("import \"%s\"", importPath))
//		newLines = append(newLines, lines[packageLine+1:]...)
//		return newLines
//	}
//	return lines
//}
//
//// injectRoutesInitCall 注入routes.Init()到main函数
//func injectRoutesInitCall(lines []string) []string {
//	// 查找main函数开头
//	mainLine := -1
//	for i, line := range lines {
//		if strings.TrimSpace(line) == "func main() {" {
//			mainLine = i
//			break
//		}
//	}
//	if mainLine == -1 {
//		return lines
//	}
//
//	// 插入调用（匹配缩进）
//	indent := strings.Repeat("\t", strings.Count(lines[mainLine], "\t"))
//	newLines := append(lines[:mainLine+1], fmt.Sprintf("%sroutes.Init()", indent))
//	newLines = append(newLines, lines[mainLine+1:]...)
//	return newLines
//}

//package autoimport
//
//import (
//	"bufio"
//	"fmt"
//	"github.com/goodbye-jack/go-common/generator"
//	"os"
//	"path/filepath"
//	"regexp"
//	"strings"
//	"sync"
//)
//
//// 全局锁：防止多goroutine重复生成
//var genLock sync.Once
//
//// 从go.mod解析module名（通用逻辑）
//func getModuleName() (string, error) {
//	// 获取项目根目录（从当前工作目录向上找go.mod）
//	wd, err := os.Getwd()
//	if err != nil {
//		return "", err
//	}
//	// 向上遍历找go.mod
//	for {
//		goModPath := filepath.Join(wd, "go.mod")
//		if _, err := os.Stat(goModPath); err == nil {
//			// 找到go.mod，解析module名
//			file, err := os.Open(goModPath)
//			if err != nil {
//				return "", err
//			}
//			defer file.Close()
//
//			moduleRegex := regexp.MustCompile(`^module\s+(\S+)$`)
//			scanner := bufio.NewScanner(file)
//			for scanner.Scan() {
//				line := strings.TrimSpace(scanner.Text())
//				if match := moduleRegex.FindStringSubmatch(line); match != nil {
//					return match[1], nil
//				}
//			}
//			return "", fmt.Errorf("go.mod中未找到module声明")
//		}
//		// 到根目录仍未找到
//		parent := filepath.Dir(wd)
//		if parent == wd {
//			return "", fmt.Errorf("未找到go.mod文件，请在项目根目录执行")
//		}
//		wd = parent
//	}
//}
//
//// 编译期自动生成路由导入文件（init触发，仅执行一次）
//func init() {
//	genLock.Do(func() {
//		// 1. 动态解析业务项目module名
//		moduleName, err := getModuleName()
//		if err != nil {
//			fmt.Printf("[autoimport] 解析module名失败（非致命，路由可能未加载）：%v\n", err)
//			return
//		}
//		// 2. 调用核心生成函数（通用默认配置，可通过环境变量自定义）
//		matchPatterns := os.Getenv("ROUTE_MATCH_PATTERNS")
//		if matchPatterns == "" {
//			matchPatterns = "internal/handler/*,*Route,*router"
//		}
//		outputDir := os.Getenv("ROUTE_OUTPUT_DIR")
//		if outputDir == "" {
//			outputDir = "routes"
//		}
//		ignoreDirs := os.Getenv("ROUTE_IGNORE_DIRS")
//		if ignoreDirs == "" {
//			ignoreDirs = "vendor,.git,testdata,docs"
//		}
//		// 3. 生成路由导入文件
//		err = generator.AutoGenRouteImport(moduleName, "", outputDir, matchPatterns, ignoreDirs)
//		if err != nil {
//			fmt.Printf("[autoimport] 生成路由文件失败（非致命，路由可能未加载）：%v\n", err)
//			return
//		}
//
//		fmt.Printf("[autoimport] ✅ 自动生成路由导入文件完成：%s/auto_import.go\n", outputDir)
//	})
//}
